import {Project} from "data/project"
import {getAllProjectModelsWithFolders, getSortedProjectBinds, mappedForestToArrayWithPath} from "data/project_utils"
import {capitalize} from "common/capitalize"
import {readdirAsArray} from "common/readdir_as_array"
import * as Path from "path"
import {DevtoolActions} from "server/actions"

export async function projectToTypescript(project: Project, actions: DevtoolActions): Promise<string> {
	const classPaths = await gatherEntityClassPaths(actions.resolveProjectPath(project.config.entityClassesDirectoryPath))

	const modelEntries = getAllProjectModelsWithFolders(project)
		.map(([pathParts]) => pathParts)

	const sortedBinds = getSortedProjectBinds(project)
	const bindSetNames = sortedBinds.map(([,path]) => path)
	const particleNames = mappedForestToArrayWithPath(project.particleTree, project.particles).map(([, path]) => path)
	const modelEnumName = project.config.ts.entityEnumName
	const bindsEnumName = project.config.ts.inputBindsEnumName
	const loaderVariableName = project.config.ts.loaderVariableName

	return `
// Generated by E8 developer tool. Direct edits will be lost.

${getCommentCode("Imports of all the entity classes.\nJust to be sure that none of those entity definitions are trimmed from the build.")}
${convertClassPathsToImports(classPaths, actions.resolveProjectPath(project.config.ts.path)).join("\n")}

import {Engine, makeE8Loader} from "@nartallax/e8"

${getCommentCode("Engine with the resourcepack loaded. Properly typed by the resourcepack data.")}
export type EngineInstance = Engine<${modelEnumName}, ${bindsEnumName}, ${project.config.ts.particleEnumName}>

${getCommentCode("Entrypoint. Only way to set up the engine.")}
export const ${loaderVariableName} = makeE8Loader<EngineInstance>()

${getConstEnumCode("", modelEnumName, "All the entities available in the resource pack", modelEntries)}

${getConstEnumCode("", bindsEnumName, "All input bind sets available in the resource pack", bindSetNames)}

${getConstEnumCode("", project.config.ts.particleEnumName, "All particle presets available in the resource pack", particleNames)}
`
}

async function gatherEntityClassPaths(root: string): Promise<string[]> {
	const entries = await readdirAsArray(root, {excludeDirectories: true})
	return entries.filter(x => x.toLowerCase().endsWith(".entity.ts"))
}

function convertClassPathsToImports(paths: string[], tsFilePath: string): string[] {
	return paths
		.map(path => Path.relative(Path.dirname(tsFilePath), path))
		.map(path => path.replace(/\\/g, "/")) // wonder if it will work on windows
		.map(path => path.replace(/\.ts/i, ""))
		.map((path, i) => `import * as _${i} from ${JSON.stringify(path)}`)
}

function getConstEnumCode(offset: string, name: string, comment: string, entries: string[][]): string {
	const knownNames = new Map<string, string[]>()

	const entryStrings = entries.map((name, index) => {
		const identifier = makeTsIdentifier(name)
		const otherName = knownNames.get(identifier)
		if(otherName){
			throw new Error(`Failed to generate enum ${name}: two different item names, ${name.join("/")} and ${otherName.join("/")}, resolve to the same identifier, ${identifier}`)
		}

		return identifier + " = " + index
	})

	return `${getCommentCode(comment)}
${offset}export const enum ${makeTsIdentifier([name], true)} {
${offset}	${entryStrings.join(",\n\t" + offset)}
${offset}}`
}

function getCommentCode(content: string): string {
	return "/** " + content.replaceAll(/[/*]/g, " ") + " */"
}


function makeTsIdentifier(parts: string[], doCapitalize = false): string {
	parts = parts.flatMap(part => part.split(" "))
	let result = parts.map((part, i) => {
		part = part
			.replaceAll(/[^a-z\d]/ig, "_")
			.replaceAll("\\s+", "_")
		if(i === 0 && (part.length === 0 || /^\d/.test(part))){
			part = "_" + part
		}

		if(i !== 0 && part.length > 0){
			part = capitalize(part)
		}

		return part
	}).filter(x => !!x).join("")

	if(doCapitalize){
		result = capitalize(result)
	}

	return result
}